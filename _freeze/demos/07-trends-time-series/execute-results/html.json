{
  "hash": "3ef356b901aaaac9b2670b6fc392a688",
  "result": {
    "markdown": "---\ntitle: \"Demo 07: Visualizing trends and time series data\"\nformat: html\n---\n\n\n# PhDs Awarded by Field Over Time\n\nIn this demo, we'll first work with a dataset on the number of PhD degrees awarded in the US from [TidyTuesday](https://github.com/rfordatascience/tidytuesday/tree/master/data/2019/2019-02-19).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Read in the tidytuesday data\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: package 'ggplot2' was built under R version 4.2.3\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: package 'tidyr' was built under R version 4.2.3\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: package 'readr' was built under R version 4.2.3\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: package 'dplyr' was built under R version 4.2.3\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: package 'stringr' was built under R version 4.2.3\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.0     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n:::\n\n```{.r .cell-code}\nphd_field <- read_csv(\"https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2019/2019-02-19/phd_by_field.csv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nRows: 3370 Columns: 5\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (3): broad_field, major_field, field\ndbl (2): year, n_phds\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n:::\n\n```{.r .cell-code}\nphd_field\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3,370 × 5\n   broad_field   major_field                                 field   year n_phds\n   <chr>         <chr>                                       <chr>  <dbl>  <dbl>\n 1 Life sciences Agricultural sciences and natural resources Agric…  2008    111\n 2 Life sciences Agricultural sciences and natural resources Agric…  2008     28\n 3 Life sciences Agricultural sciences and natural resources Agric…  2008      3\n 4 Life sciences Agricultural sciences and natural resources Agron…  2008     68\n 5 Life sciences Agricultural sciences and natural resources Anima…  2008     41\n 6 Life sciences Agricultural sciences and natural resources Anima…  2008     18\n 7 Life sciences Agricultural sciences and natural resources Anima…  2008     77\n 8 Life sciences Agricultural sciences and natural resources Envir…  2008    182\n 9 Life sciences Agricultural sciences and natural resources Fishi…  2008     52\n10 Life sciences Agricultural sciences and natural resources Food …  2008     96\n# ℹ 3,360 more rows\n```\n:::\n:::\n\n\nLet's start by grabbing the rows corresponding to Statistics PhDs. While there are a number of ways to do this, we can grab `field` containing \"statistics\" (including biostatistics) with the `str_detect()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstats_phds <- phd_field |>\n  filter(str_detect(tolower(field), \"statistics\"))\n```\n:::\n\n\nWhat are the different fields that were captured?\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(stats_phds$field)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n                       Biometrics and biostatistics \n                                                 10 \n           Educational statistics, research methods \n                                                 10 \nManagement information systems, business statistics \n                                                 10 \n                Mathematics and statistics, general \n                                                 10 \n                  Mathematics and statistics, other \n                                                 10 \n                           Statistics (mathematics) \n                                                 10 \n                       Statistics (social sciences) \n                                                 10 \n```\n:::\n:::\n\n\nTo start, let's just summarize the number of PhDs by `year`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstat_phd_year_summary <- stats_phds |>\n  group_by(year) |>\n  summarize(n_phds = sum(n_phds))\n```\n:::\n\n\nNow, we'll make the typical scatterplot display with `n_phds` on the y-axis and `year` on the x-axis:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstat_phd_year_summary |>\n  ggplot(aes(x = year, y = n_phds)) +\n  geom_point() +\n  theme_bw() +\n  labs(x = \"Year\", y = \"Number of PhDs\",\n       title = \"Number of Statistics-related PhDs awarded over time\")\n```\n\n::: {.cell-output-display}\n![](07-trends-time-series_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\nWe should fix our x-axis here and make the breaks more informative. In this case,\nI'll change it so each year is labeled (that may not be appropriate for every visual but it works out here).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstat_phd_year_summary |>\n  ggplot(aes(x = year, y = n_phds)) +\n  geom_point() +\n  # Modify the x-axis to make the axis breaks at the unique years and show their\n  # respective labels\n  scale_x_continuous(breaks = unique(stat_phd_year_summary$year),\n                     labels = unique(stat_phd_year_summary$year)) +\n  theme_bw() +\n  labs(x = \"Year\", y = \"Number of PhDs\",\n       title = \"Number of Statistics-related PhDs awarded over time\")\n```\n\n::: {.cell-output-display}\n![](07-trends-time-series_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\nTo emphasize the ordering of the year along the x-axis, we'll add a line connecting the points to emphasize the order:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstat_phd_year_summary |>\n  ggplot(aes(x = year, y = n_phds)) +\n  geom_point() +\n  geom_line() +\n  scale_x_continuous(breaks = unique(stat_phd_year_summary$year),\n                     labels = unique(stat_phd_year_summary$year)) +\n  theme_bw() +\n  labs(x = \"Year\", y = \"Number of PhDs\",\n       title = \"Number of Statistics-related PhDs awarded over time\")\n```\n\n::: {.cell-output-display}\n![](07-trends-time-series_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\nWe can drop the points, leaving only the connecting lines to emphasize trends:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstat_phd_year_summary |>\n  ggplot(aes(x = year, y = n_phds)) +\n  geom_line() +\n  scale_x_continuous(breaks = unique(stat_phd_year_summary$year),\n                     labels = unique(stat_phd_year_summary$year)) +\n  theme_bw() +\n  labs(x = \"Year\", y = \"Number of PhDs\",\n       title = \"Number of Statistics-related PhDs awarded over time\")\n```\n\n::: {.cell-output-display}\n![](07-trends-time-series_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\nAnother common way to display trends is by filling in the area under the line. However, this is only appropriate when the y-axis starts at 0! It's also redundant use of ink so just be careful when deciding whether or not to fill the area. We can fill the area under the line with the `geom_area()` aesthetic - but note that it changes the y-axis by default to start at 0:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstat_phd_year_summary |>\n  ggplot(aes(x = year, y = n_phds)) +\n  # Fill the area under the line\n  geom_area(fill = \"darkblue\", alpha = 0.5) +\n  geom_line() +\n  scale_x_continuous(breaks = unique(stat_phd_year_summary$year),\n                     labels = unique(stat_phd_year_summary$year)) +\n  theme_bw() +\n  labs(x = \"Year\", y = \"Number of PhDs\",\n       title = \"Number of Statistics-related PhDs awarded over time\")\n```\n\n::: {.cell-output-display}\n![](07-trends-time-series_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\nYou can also make this plot using the [`ggridges` package](https://cran.r-project.org/web/packages/ggridges/vignettes/introduction.html).\n\n# Plotting and labeling several lines\n\nWe'll now switch to displaying the different Statistics fields separately with the `stats_phds` dataset. First, __we should NOT display multiple time series with just points as follows__:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstats_phds |>\n  ggplot(aes(x = year, y = n_phds, color = field)) +\n  geom_point() +\n  scale_x_continuous(breaks = unique(stat_phd_year_summary$year),\n                     labels = unique(stat_phd_year_summary$year)) +\n  theme_bw() +\n  theme(legend.position = \"bottom\",\n        # Adjust the size of the legend's text\n        legend.text = element_text(size = 5),\n        legend.title = element_text(size = 6)) +\n  labs(x = \"Year\", y = \"Number of PhDs\",\n       title = \"Number of Statistics-related PhDs awarded over time\",\n       color = \"Field\")\n```\n\n::: {.cell-output-display}\n![](07-trends-time-series_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\nIt's much simpler to just display the lines to compare the trends:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstats_phds |>\n  ggplot(aes(x = year, y = n_phds, color = field)) +\n  geom_line() +\n  scale_x_continuous(breaks = unique(stat_phd_year_summary$year),\n                     labels = unique(stat_phd_year_summary$year)) +\n  theme_bw() +\n  theme(legend.position = \"bottom\",\n        # Adjust the size of the legend's text\n        legend.text = element_text(size = 5),\n        legend.title = element_text(size = 6)) +\n  labs(x = \"Year\", y = \"Number of PhDs\",\n       title = \"Number of Statistics-related PhDs awarded over time\",\n       color = \"Field\")\n```\n\n::: {.cell-output-display}\n![](07-trends-time-series_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\nThe legend is pretty cluttered though, instead we can directly label the displayed lines using the [`ggrepel` package](https://ggrepel.slowkow.com/articles/examples.html). We first need to create a dataset with just the final values (which in this case corresponds to `year == 2017`), and then add labels for these values. To make the labels visible, we need to increase our x-axis limits. Note that this is a \"hack\", but you will rely on hacks to customize visuals in the future... The following code chunk demonstrates how to do this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstats_phds_2017 <- stats_phds |>\n  filter(year == 2017)\n\n# Access the ggrepel package:\n# install.packages(\"ggrepel\")\nlibrary(ggrepel)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: package 'ggrepel' was built under R version 4.2.3\n```\n:::\n\n```{.r .cell-code}\nstats_phds |>\n  ggplot(aes(x = year, y = n_phds, color = field)) +\n  geom_line() +\n  # Add the labels:\n  geom_text_repel(data = stats_phds_2017,\n                  aes(label = field),\n                  size = 2, \n                  # Drop the segment connection:\n                  segment.color = NA, \n                  # Move labels up or down based on overlap\n                  direction = \"y\",\n                  # Try to align the labels horizontally on the left hand side\n                  hjust = \"left\") +\n  scale_x_continuous(breaks = unique(stat_phd_year_summary$year),\n                     labels = unique(stat_phd_year_summary$year),\n                     # Update the limits so that there is some padding on the\n                     # x-axis but don't label the new maximum\n                     limits = c(min(stat_phd_year_summary$year),\n                                max(stat_phd_year_summary$year) + 3)) +\n  theme_bw() +\n  # Drop the legend\n  theme(legend.position = \"none\") +\n  labs(x = \"Year\", y = \"Number of PhDs\",\n       title = \"Number of Statistics-related PhDs awarded over time\",\n       color = \"Field\")\n```\n\n::: {.cell-output-display}\n![](07-trends-time-series_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n\nAn alternative approach is to use the [`gghighlight` package](https://yutannihilation.github.io/gghighlight/articles/gghighlight.html):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(gghighlight)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: package 'gghighlight' was built under R version 4.2.3\n```\n:::\n\n```{.r .cell-code}\nstats_phds |>\n  ggplot(aes(x = year, y = n_phds, color = field)) +\n  geom_line() +\n  gghighlight()  +\n  scale_x_continuous(breaks = unique(stat_phd_year_summary$year),\n                     labels = unique(stat_phd_year_summary$year)) +\n  theme_light() +\n  theme(legend.position = \"none\") +\n  labs(x = \"Year\", y = \"Number of PhDs\", color = \"Field\",\n       title = \"Number of Statistics-related PhDs awarded over time\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nlabel_key: field\n```\n:::\n\n::: {.cell-output-display}\n![](07-trends-time-series_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\nNext, let's switch to back to the original dataset `phd_field`. What happens if we plot a line for every field attempting to use the `color` aesthetic to separate them?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nphd_field |>\n  ggplot(aes(x = year, y = n_phds, color = field)) +\n  geom_line() +\n  scale_x_continuous(breaks = unique(stat_phd_year_summary$year),\n                     labels = unique(stat_phd_year_summary$year)) +\n  theme_bw() +\n  theme(legend.position = \"none\") +\n  labs(x = \"Year\", y = \"Number of PhDs\",\n       title = \"Number of Statistics-related PhDs awarded over time\",\n       color = \"Field\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Removed 270 rows containing missing values or values outside the scale range\n(`geom_line()`).\n```\n:::\n\n::: {.cell-output-display}\n![](07-trends-time-series_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n\nThe plot above is obviously a disaster... When we are dealing with potentially way too many categories, we can instead highlight lines of interest while setting the background lines to gray, so we can still see background trends. We need to use the `group` aesthetic to split the gray lines from each other. Plus, we should adjust the alpha due to the overlap. The following code chunk demonstrates how to do this for highlighting the \"Statistics (mathematics)\" and \"Biometrics and biostatistics\" lines. We essentially create separate plot layers by filtering on the `field` variable:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# First display the background lines using the full dataset with those two fields \n# filtered out:\nphd_field |>\n  # The following line says: NOT (field in c(\"Biometrics and biostatistics\", \"Statistics (mathematics)\"))\n  filter(!(field %in% c(\"Biometrics and biostatistics\", \n                        \"Statistics (mathematics)\"))) |>\n  ggplot() +\n  # Add the background lines - need to specify the group to be the field\n  geom_line(aes(x = year, y = n_phds, group = field),\n            color = \"gray\", size = .5, alpha = .5) +\n  # Now add the layer with the lines of interest:\n  geom_line(data = filter(phd_field,\n                          # Note this is just the opposite of the above since ! is removed\n                          field %in% c(\"Biometrics and biostatistics\", \n                                       \"Statistics (mathematics)\")),\n            aes(x = year, y = n_phds, color = field),\n            # Make the size larger\n            size = .75, alpha = 1) +\n  scale_x_continuous(breaks = unique(stat_phd_year_summary$year),\n                     labels = unique(stat_phd_year_summary$year)) +\n  theme_bw() +\n  theme(legend.position = \"bottom\", \n        # Drop the panel lines making the gray difficult to see\n        panel.grid = element_blank()) +\n  labs(x = \"Year\", y = \"Number of PhDs\",\n       title = \"Number of Statistics-related PhDs awarded over time\",\n       color = \"Field\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Removed 270 rows containing missing values or values outside the scale range\n(`geom_line()`).\n```\n:::\n\n::: {.cell-output-display}\n![](07-trends-time-series_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n\n\n# Florence Nightingale’s rose diagrams\n\nAnother way to visualize time series data is to display it in a cycle pattern, using polar coordinates, as done by Florence Nightingale's famous rose diagram. We can recreate the rose diagram by accessing the data in the `HistData` package. We'll first load and print out the first so many rows of the data below:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(HistData)\nhead(Nightingale)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        Date Month Year  Army Disease Wounds Other Disease.rate Wounds.rate\n1 1854-04-01   Apr 1854  8571       1      0     5          1.4         0.0\n2 1854-05-01   May 1854 23333      12      0     9          6.2         0.0\n3 1854-06-01   Jun 1854 28333      11      0     6          4.7         0.0\n4 1854-07-01   Jul 1854 28722     359      0    23        150.0         0.0\n5 1854-08-01   Aug 1854 30246     828      1    30        328.5         0.4\n6 1854-09-01   Sep 1854 30290     788     81    70        312.2        32.1\n  Other.rate\n1        7.0\n2        4.6\n3        2.5\n4        9.6\n5       11.9\n6       27.7\n```\n:::\n:::\n\n\nTo recreate the plot, we'll need to first make a longer version of the dataset with the `Disease`, `Wounds`, and `Other` columns separated into three rows. To do that, we'll use the `pivot_longer()` function after just selecting the columns of interest for our plot:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncrimean_war_data <- Nightingale |>\n  dplyr::select(Date, Month, Year, Disease, Wounds, Other) |>\n  # Now pivot those columns to take up separate rows:\n  pivot_longer(Disease:Other,\n               names_to = \"cause\", values_to = \"count\")\n```\n:::\n\n\nNext, we'll make a label column matching Nightingale's plot based on the `Date` column. We'll talk about dates more below, but we can condition on being above or below certain dates in a natural way:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncrimean_war_data <- crimean_war_data |>\n  mutate(time_period = ifelse(Date <= as.Date(\"1855-03-01\"),\n                              \"April 1854 to March 1855\", \n                              \"April 1855 to March 1856\"))\n```\n:::\n\n\nAnd finally we can go ahead and display the rose diagram facetted by the time\nperiod (using similar colors to Nightingale):\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncrimean_war_data |> \n  ggplot(aes(x = Month, y = count)) + \n  geom_col(aes(fill = cause), width = 1, \n           position = \"identity\", alpha = 0.5) + \n  coord_polar() + \n  facet_wrap(~ time_period, ncol = 2) +\n  scale_fill_manual(values = c(\"skyblue3\", \"grey30\", \"firebrick\")) +\n  scale_y_sqrt() +\n  theme_void() +\n  # All of this below is to just customize the theme in a way that we are\n  # close to resembling the original plot (ie lets make it look old!)\n  theme(axis.text.x = element_text(size = 9),\n        strip.text = element_text(size = 11),\n        legend.position = \"bottom\",\n        plot.background = element_rect(fill = alpha(\"cornsilk\", 0.5)),\n        plot.margin = unit(c(10, 10, 10, 10), \"pt\"),\n        plot.title = element_text(vjust = 5)) +\n  labs(title = \"Diagram of the Causes of Mortality in the Army in the East\")\n```\n\n::: {.cell-output-display}\n![](07-trends-time-series_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n:::\n\n\nThis looks pretty close to the original diagram, except the order of the months does not match the original. We can of course change that by reordering the factor variable:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncrimean_war_data |> \n  # Manually relevel it to match the original plot\n  mutate(Month = fct_relevel(Month, \n                             \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\",\n                             \"Dec\", \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\")) |>\n  ggplot(aes(x = Month, y = count)) + \n  geom_col(aes(fill = cause), width = 1, \n           position = \"identity\", alpha = 0.5) + \n  coord_polar() + \n  facet_wrap(~ time_period, ncol = 2) +\n  scale_fill_manual(values = c(\"skyblue3\", \"grey30\", \"firebrick\")) +\n  scale_y_sqrt() +\n  theme_void() +\n  # All of this below is to just customize the theme in a way that we are\n  # close to resembling the original plot (ie lets make it look old!)\n  theme(axis.text.x = element_text(size = 9),\n        strip.text = element_text(size = 11),\n        legend.position = \"bottom\",\n        plot.background = element_rect(fill = alpha(\"cornsilk\", 0.5)),\n        plot.margin = unit(c(10, 10, 10, 10), \"pt\"),\n        plot.title = element_text(vjust = 5)) +\n  labs(title = \"Diagram of the Causes of Mortality in the Army in the East\")\n```\n\n::: {.cell-output-display}\n![](07-trends-time-series_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n:::\n\n\nHow does this compare to just a simple line graph?\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncrimean_war_data |> \n  ggplot(aes(x = Date, y = count, color = cause)) + \n  geom_line() +\n  # Add a reference line at the cutoff point\n  geom_vline(xintercept = as.Date(\"1855-03-01\"), linetype = \"dashed\",\n             color = \"gray\") +\n  scale_color_manual(values = c(\"skyblue3\", \"grey30\", \"firebrick\")) +\n  theme_bw() +\n  theme(legend.position = \"bottom\") +\n  labs(title = \"Diagram of the Causes of Mortality in the Army in the East\",\n       y = \"Counts\", x = \"Date\")\n```\n\n::: {.cell-output-display}\n![](07-trends-time-series_files/figure-html/unnamed-chunk-21-1.png){width=672}\n:::\n:::\n\n\nWe can customize the x-axis further using [`scale_x_date()`](https://www.datanovia.com/en/blog/ggplot-date-axis-customization/):\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncrimean_war_data |> \n  ggplot(aes(x = Date, y = count, color = cause)) + \n  geom_line() +\n  # Add a reference line at the cutoff point\n  geom_vline(xintercept = as.Date(\"1855-03-01\"), linetype = \"dashed\",\n             color = \"gray\") +\n  scale_color_manual(values = c(\"skyblue3\", \"grey30\", \"firebrick\")) +\n  # Format to use abbreviate month %b with year %Y\n  scale_x_date(date_labels = \"%b %Y\") +\n  theme_bw() +\n  theme(legend.position = \"bottom\") +\n  labs(title = \"Diagram of the Causes of Mortality in the Army in the East\",\n       y = \"Counts\", x = \"Date\")\n```\n\n::: {.cell-output-display}\n![](07-trends-time-series_files/figure-html/unnamed-chunk-22-1.png){width=672}\n:::\n:::\n\n\nWhich one do you prefer? Maybe filling the area under the lines would be better here...\n\n# Time Series Data Structure and Basic Plots\n\nA **time series** measures a single variable over many points in time. Time intervals may be regularly or irregularly spaced, but we'll only consider regularly-spaced data today. We'll focus on visualizing a single variable over time, since there are already so many choices and information to work with. \n\nFor this demo, we're going to work with a dataset that's actually already loaded when you start `R`: it's defined under `co2`, and known as the \"Mauna Loa Atmospheric CO2 Concentration\" dataset. This dataset contains 468 monthly measurements of CO2 concentration from 1959 to 1997.\n\nWhen you start `R`, if you type in `co2`, this is what you'll see:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nco2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        Jan    Feb    Mar    Apr    May    Jun    Jul    Aug    Sep    Oct\n1959 315.42 316.31 316.50 317.56 318.13 318.00 316.39 314.65 313.68 313.18\n1960 316.27 316.81 317.42 318.87 319.87 319.43 318.01 315.74 314.00 313.68\n1961 316.73 317.54 318.38 319.31 320.42 319.61 318.42 316.63 314.83 315.16\n1962 317.78 318.40 319.53 320.42 320.85 320.45 319.45 317.25 316.11 315.27\n1963 318.58 318.92 319.70 321.22 322.08 321.31 319.58 317.61 316.05 315.83\n1964 319.41 320.07 320.74 321.40 322.06 321.73 320.27 318.54 316.54 316.71\n1965 319.27 320.28 320.73 321.97 322.00 321.71 321.05 318.71 317.66 317.14\n1966 320.46 321.43 322.23 323.54 323.91 323.59 322.24 320.20 318.48 317.94\n1967 322.17 322.34 322.88 324.25 324.83 323.93 322.38 320.76 319.10 319.24\n1968 322.40 322.99 323.73 324.86 325.40 325.20 323.98 321.95 320.18 320.09\n1969 323.83 324.26 325.47 326.50 327.21 326.54 325.72 323.50 322.22 321.62\n1970 324.89 325.82 326.77 327.97 327.91 327.50 326.18 324.53 322.93 322.90\n1971 326.01 326.51 327.01 327.62 328.76 328.40 327.20 325.27 323.20 323.40\n1972 326.60 327.47 327.58 329.56 329.90 328.92 327.88 326.16 324.68 325.04\n1973 328.37 329.40 330.14 331.33 332.31 331.90 330.70 329.15 327.35 327.02\n1974 329.18 330.55 331.32 332.48 332.92 332.08 331.01 329.23 327.27 327.21\n1975 330.23 331.25 331.87 333.14 333.80 333.43 331.73 329.90 328.40 328.17\n1976 331.58 332.39 333.33 334.41 334.71 334.17 332.89 330.77 329.14 328.78\n1977 332.75 333.24 334.53 335.90 336.57 336.10 334.76 332.59 331.42 330.98\n1978 334.80 335.22 336.47 337.59 337.84 337.72 336.37 334.51 332.60 332.38\n1979 336.05 336.59 337.79 338.71 339.30 339.12 337.56 335.92 333.75 333.70\n1980 337.84 338.19 339.91 340.60 341.29 341.00 339.39 337.43 335.72 335.84\n1981 339.06 340.30 341.21 342.33 342.74 342.08 340.32 338.26 336.52 336.68\n1982 340.57 341.44 342.53 343.39 343.96 343.18 341.88 339.65 337.81 337.69\n1983 341.20 342.35 342.93 344.77 345.58 345.14 343.81 342.21 339.69 339.82\n1984 343.52 344.33 345.11 346.88 347.25 346.62 345.22 343.11 340.90 341.18\n1985 344.79 345.82 347.25 348.17 348.74 348.07 346.38 344.51 342.92 342.62\n1986 346.11 346.78 347.68 349.37 350.03 349.37 347.76 345.73 344.68 343.99\n1987 347.84 348.29 349.23 350.80 351.66 351.07 349.33 347.92 346.27 346.18\n1988 350.25 351.54 352.05 353.41 354.04 353.62 352.22 350.27 348.55 348.72\n1989 352.60 352.92 353.53 355.26 355.52 354.97 353.75 351.52 349.64 349.83\n1990 353.50 354.55 355.23 356.04 357.00 356.07 354.67 352.76 350.82 351.04\n1991 354.59 355.63 357.03 358.48 359.22 358.12 356.06 353.92 352.05 352.11\n1992 355.88 356.63 357.72 359.07 359.58 359.17 356.94 354.92 352.94 353.23\n1993 356.63 357.10 358.32 359.41 360.23 359.55 357.53 355.48 353.67 353.95\n1994 358.34 358.89 359.95 361.25 361.67 360.94 359.55 357.49 355.84 356.00\n1995 359.98 361.03 361.66 363.48 363.82 363.30 361.94 359.50 358.11 357.80\n1996 362.09 363.29 364.06 364.76 365.45 365.01 363.70 361.54 359.51 359.65\n1997 363.23 364.06 364.61 366.40 366.84 365.68 364.52 362.57 360.24 360.83\n        Nov    Dec\n1959 314.66 315.43\n1960 314.84 316.03\n1961 315.94 316.85\n1962 316.53 317.53\n1963 316.91 318.20\n1964 317.53 318.55\n1965 318.70 319.25\n1966 319.63 320.87\n1967 320.56 321.80\n1968 321.16 322.74\n1969 322.69 323.95\n1970 323.85 324.96\n1971 324.63 325.85\n1972 326.34 327.39\n1973 327.99 328.48\n1974 328.29 329.41\n1975 329.32 330.59\n1976 330.14 331.52\n1977 332.24 333.68\n1978 333.75 334.78\n1979 335.12 336.56\n1980 336.93 338.04\n1981 338.19 339.44\n1982 339.09 340.32\n1983 340.98 342.82\n1984 342.80 344.04\n1985 344.06 345.38\n1986 345.48 346.72\n1987 347.64 348.78\n1988 349.91 351.18\n1989 351.14 352.37\n1990 352.69 354.07\n1991 353.64 354.89\n1992 354.09 355.33\n1993 355.30 356.78\n1994 357.59 359.05\n1995 359.61 360.74\n1996 360.80 362.38\n1997 362.49 364.34\n```\n:::\n:::\n\n\nThese numbers are expressed in parts per million (ppm) - if you've taken a chemistry class (which I haven't), I assure you know more about this than I do, but ppm is a very common measure for pollutants and contaminants.\n\nThe `co2` object is actually defined with a class we haven't seen yet, `ts` (time series):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(co2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"ts\"\n```\n:::\n:::\n\n\nAs a result, it contains extra attributes about the times associated with each value, and base `R` graphs can plot this automatically (we don't need to specify the time range manually):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(co2)\n```\n\n::: {.cell-output-display}\n![](07-trends-time-series_files/figure-html/unnamed-chunk-25-1.png){width=672}\n:::\n:::\n\n\nThis is typically called a line plot. Here's how you would plot the same data in the `gg` style (note that you need the package `ggfortify` to do this) without constructing the typical long-table format we're used to:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggfortify)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: package 'ggfortify' was built under R version 4.2.3\n```\n:::\n\n```{.r .cell-code}\nautoplot(co2)\n```\n\n::: {.cell-output-display}\n![](07-trends-time-series_files/figure-html/unnamed-chunk-26-1.png){width=672}\n:::\n:::\n\n\nIn time series, we are interested in checking for trends (does the variable tend to increase or decrease over time?), seasonality (are there tendencies that regularly occur? If so, at what intervals do they occur?), general variability (i.e., variation beyond average trends and seasonality), and outliers (unusual spikes or valleys). Which of these do we see in the `co2` data?\n\nIn order to show you more general-purpose plotting methods, we'll treat `co2` as `numeric` instead of `ts` from now on. This is actually the form that many time series data take (they're usually not in the `ts` format), so this will also show you some of the formatting/structuring issues you'll have to work with in the wild.\n\nIn the code below, we create a dataset with 1:468 as the `obs_i` variable (x-axis variable) and the CO2 concentration as the `co2_val` variable (y-axis) variable). Then, we use our usual `ggplot` to plot the data:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nco2_tbl <- tibble(co2_val = as.numeric(co2)) |>\n  mutate(obs_i = 1:n())\nco2_tbl |>\n  ggplot(aes(x = obs_i, y = co2_val)) + \n  geom_line() + \n  labs(x = \"Time index\", y = \"CO2 (ppm)\")\n```\n\n::: {.cell-output-display}\n![](07-trends-time-series_files/figure-html/unnamed-chunk-27-1.png){width=672}\n:::\n:::\n\n\nNote the x-axis: This will not be helpful/informative to readers. It's a *common* mistake for people to just put something like \"index\" on the x-axis, but they don't even tell you what they are indexing. Be sure to not make this mistake! To properly structure time series data and label it correctly, you'll need to know how to work with `Date` type objects in `R` (which we will discuss next...).\n\n## Formatting `Date` data in R\n\nThe following code redefines creates a new  column in our dataset to be the monthly dates 1/1/1959, 2/1/1959, ... , 12/1/1997 using the `as.Date()` function (given the description of the time range in `help(co2)`):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nco2_tbl <- co2_tbl |>\n  # We can use the seq() function with dates which is pretty useful!\n  mutate(obs_date = seq(as.Date(\"1959/1/1\"), by = \"month\",\n                        length.out = n()))\nco2_tbl |>\n  ggplot(aes(x = obs_date, y = co2_val)) + \n  geom_line() + \n  labs(x = \"Year\", y = \"CO2 (ppm)\")\n```\n\n::: {.cell-output-display}\n![](07-trends-time-series_files/figure-html/unnamed-chunk-28-1.png){width=672}\n:::\n:::\n\n\nUnfortunately, the default format for dates in `as.Date()` is Year/Month/Day. If you prefer another format, such as the common Month/Day/Year (as I used above in the previous paragraph), you need to include the `format` argument within `as.Date()`, as such (**note that the Y is capitalized - yes, `as.Date()` is that picky**):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nco2_tbl <- co2_tbl |>\n  mutate(obs_date = seq(as.Date(\"1/1/1959\", format = \"%m/%d/%Y\"), \n                        by = \"month\",\n                        length.out = n()))\nco2_tbl |>\n  ggplot(aes(x = obs_date, y = co2_val)) + \n  geom_line() + \n  labs(x = \"Year\", y = \"CO2 (ppm)\")\n```\n\n::: {.cell-output-display}\n![](07-trends-time-series_files/figure-html/unnamed-chunk-29-1.png){width=672}\n:::\n:::\n\n\nNote that all we needed to do was convert the `obs_date` variable to a `Date` class, and then we could use `ggplot` as is. This is because `ggplot` knows to use a special date scale for the x-axis when x has class `Date.` As a result, we can easily play with the breaks on the date axis using `scale_x_date()`. For example:\n\n+ For a subset of the data, maybe we only want ticks every 4 months, using `date_breaks`.\n+ We can specify the format of the date with `date_labels`. (See Details section of `?strftime` for the formatting options. Here, we choose abbreviated month `%b` and full year `%Y`.)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nco2_tbl[1:26,] |>\n  ggplot(aes(x = obs_date, y = co2_val)) + \n  geom_line() + \n  scale_x_date(date_breaks = \"4 months\", date_labels = \"%b %Y\") +\n  labs(x = \"Year\", y = \"CO2 (ppm)\") +\n  # Modify the x-axis text \n  theme(axis.text.x = element_text(angle = 45, hjust = 1))\n```\n\n::: {.cell-output-display}\n![](07-trends-time-series_files/figure-html/unnamed-chunk-30-1.png){width=672}\n:::\n:::\n\n\n\n# Moving window averages\n\nOne of the things we look for in time series data are trends. But measurements can be quite noisy, making it hard to see the underlying trend. For example: Most investors probably shouldn't react by selling or buying every time the stock market jumps up or down a little bit, but it might make sense to respond to a longer-term underlying trend.\n\nAs we discussed in lecture, moving averages are a great way to get an idea of underlying trends. The `ggseas` package has a function called `stat_rollapplyr()` for computing moving averages. Below is an example of computing (and displaying) a moving average using this function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggseas)\nco2_tbl |>\n  ggplot(aes(x = obs_date, y = co2_val)) + \n  geom_line(color=\"red\") +\n  stat_rollapplyr(width = 12, align = \"right\") +\n  labs(x = \"Year\", y = \"CO2 (ppm)\", \n       title = \"Width = 12\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Removed 11 rows containing missing values or values outside the scale range\n(`geom_line()`).\n```\n:::\n\n::: {.cell-output-display}\n![](07-trends-time-series_files/figure-html/unnamed-chunk-31-1.png){width=672}\n:::\n:::\n\n\nLet's look at the `stat_rollapplyr()` line more closely. Setting `width = 12` and `align = \"right\"` states, \"For each point, plot the average of that point and the 11 points behind it.\" Since this is monthly data, __this is the average of a year's worth of data__. Given this, think about why there is no trend line for the first 11 points on the left-hand side of the graph.\n\nTo get a better idea of what happens when we change the `width` argument, below is an example of setting `width = 2` and `width = 24`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# The patchwork package provides a convenient way to arrange plots\nlibrary(patchwork)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: package 'patchwork' was built under R version 4.2.3\n```\n:::\n\n```{.r .cell-code}\nwid2 <- co2_tbl |>\n  ggplot(aes(x = obs_date, y = co2_val)) + \n  geom_line(color=\"red\") +\n  stat_rollapplyr(width = 2, align = \"right\") +\n  labs(x = \"Year\", y = \"CO2 (ppm)\", \n       title = \"Width = 2\")\n\nwid24 <- co2_tbl |>\n  ggplot(aes(x = obs_date, y = co2_val)) + \n  geom_line(color=\"red\") +\n  stat_rollapplyr(width = 24, align = \"right\") +\n  labs(x = \"Year\", y = \"CO2 (ppm)\", \n       title = \"Width = 24\")\nwid2 + wid24\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Removed 1 row containing missing values or values outside the scale range\n(`geom_line()`).\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Removed 23 rows containing missing values or values outside the scale range\n(`geom_line()`).\n```\n:::\n\n::: {.cell-output-display}\n![](07-trends-time-series_files/figure-html/unnamed-chunk-32-1.png){width=672}\n:::\n:::\n\n\nSetting `width` to be smaller gives us a line that fits the data much better, but it's also much less smooth. (In fact, setting `width = 1` is literally the data itself.) Meanwhile, setting `width` to be larger gives us a much smoother fit, but it doesn't fit the data as precisely. Ultimately, choosing how much smoothness you want for your visual is very much an art: You want the trend to be smooth enough that you get an idea of the overall trend, but you also don't want to deviate from your data too much. Some choices are better than others: For example, below is a trend line whose `width` is obviously too large (obviously because the trend line doesn't fit the data well at all).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nco2_tbl |>\n  ggplot(aes(x = obs_date, y = co2_val)) + \n  geom_line(color=\"red\") +\n  stat_rollapplyr(width = 100, align = \"right\") +\n  labs(x = \"Year\", y = \"CO2 (ppm)\", \n       title = \"Width = 100\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Removed 99 rows containing missing values or values outside the scale range\n(`geom_line()`).\n```\n:::\n\n::: {.cell-output-display}\n![](07-trends-time-series_files/figure-html/unnamed-chunk-33-1.png){width=672}\n:::\n:::\n\n\nOne last thing to note is that moving averages are extremely similar to loess smoothing. Moving averages compute the average outcome within a sliding window; meanwhile, loess computes a weighted linear regression within a sliding window. Indeed, loess can be used for understand the overall trend of a time series as well:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmoving_ave_plot <- co2_tbl |>\n  ggplot(aes(x = obs_date, y = co2_val)) + \n  geom_line(color = \"red\") +\n  stat_rollapplyr(width = 12, align = \"right\") +\n  labs(x = \"Year\", y = \"CO2 (ppm)\", \n       title = \"Width = 12\")\n\nloess_plot <- co2_tbl |>\n  ggplot(aes(x = obs_date, y = co2_val)) + \n  geom_line(color = \"red\") +\n  geom_smooth(method = \"loess\") +\n  labs(x = \"Year\", y = \"CO2 (ppm)\", title = \"Loess\")\n\nmoving_ave_plot + loess_plot\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Removed 11 rows containing missing values or values outside the scale range\n(`geom_line()`).\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n`geom_smooth()` using formula = 'y ~ x'\n```\n:::\n\n::: {.cell-output-display}\n![](07-trends-time-series_files/figure-html/unnamed-chunk-34-1.png){width=672}\n:::\n:::\n\n\nMoving averages actually literally *are* loess, but with the formula `y ~ 1` instead of `y ~ x` (i.e., an intercept-only model), and using a rectangular kernel (which is the NOT the default in `loess()` in `R`).\n\n\n# Adding lines and rectangles to a time series\n\nIf a specific event in time has a notable effect on your time series data, it is common to mark that event with a vertical line, or with rectangular shading if that event occurs over a period of time. For example, it's common for financial data to denote recessions with gray rectangular shading (this is often called \"recession shading\"), because economic recessions have notable impacts on financial data.\n\nTo add a vertical line to your time series, you just use `geom_vline()`. For example, here is a plot of the `co2_tbl` data with a vertical line for the beginning of 1980:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nco2_tbl |>\n  ggplot(aes(x = obs_date, y = co2_val)) + \n  geom_line(color = \"red\") +\n  stat_rollapplyr(width = 12, align = \"right\") +\n  geom_vline(aes(xintercept = as.Date(\"1980-01-01\"))) +\n  labs(x = \"Year\", y = \"CO2 (ppm)\", \n       title = \"CO2 Emissions Over Time\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Removed 11 rows containing missing values or values outside the scale range\n(`geom_line()`).\n```\n:::\n\n::: {.cell-output-display}\n![](07-trends-time-series_files/figure-html/unnamed-chunk-35-1.png){width=672}\n:::\n:::\n\n\nNote that the `xintercept` has to have a very particular format: It has to be a date that has the same dating format as your data. For example, here is the exact same code, but with the more common Month-Day-Year format for the date; the line will not display (presumably because it thinks I'm trying to add a vertical line for Year 1):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nco2_tbl |>\n  ggplot(aes(x = obs_date, y = co2_val)) + \n  geom_line(color = \"red\") +\n  stat_rollapplyr(width = 12, align = \"right\") +\n  geom_vline(aes(xintercept = as.Date(\"01-01-1980\"))) +\n  labs(x = \"Year\", y = \"CO2 (ppm)\", \n       title = \"CO2 Emissions Over Time\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Removed 11 rows containing missing values or values outside the scale range\n(`geom_line()`).\n```\n:::\n\n::: {.cell-output-display}\n![](07-trends-time-series_files/figure-html/unnamed-chunk-36-1.png){width=672}\n:::\n:::\n\n\nFurthermore, note that you cannot just put an integer (e.g., the year) into `geom_vline()` when plotting a time series in this way. For example, here is what happens when I try to just input the number 1980 (thinking I'll draw a line at the year 1980):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nco2_tbl |>\n  ggplot(aes(x = obs_date, y = co2_val)) + \n  geom_line(color = \"red\") +\n  stat_rollapplyr(width = 12, align = \"right\") +\n  geom_vline(aes(xintercept = 1980)) +\n  labs(x = \"Year\", y = \"CO2 (ppm)\", \n       title = \"CO2 Emissions Over Time\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Removed 11 rows containing missing values or values outside the scale range\n(`geom_line()`).\n```\n:::\n\n::: {.cell-output-display}\n![](07-trends-time-series_files/figure-html/unnamed-chunk-37-1.png){width=672}\n:::\n:::\n\n\nMeanwhile, to add rectangular shading to a time series plot, you use `geom_rect()`, which we haven't seen before. However, it's very intuitive: Within `aes()`, you just need to specify an `xmin`, `xmax`, `ymin`, and `ymax`. For example, below is our time series with gray shading between 1980 and 1990:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nco2_tbl |>\n  ggplot(aes(x = obs_date, y = co2_val)) + \n  geom_rect(aes(xmin = as.Date(\"1980-01-01\"), xmax = as.Date(\"1989-12-31\"),\n                ymin = -Inf, ymax = Inf),\n            fill = \"grey\", alpha = 0.5) +\n  geom_line(color = \"red\") +\n  stat_rollapplyr(width = 12, align = \"right\") +\n  geom_vline(aes(xintercept = as.Date(\"01-01-1980\"))) +\n  labs(x = \"Year\", y = \"CO2 (ppm)\", \n       title = \"CO2 Emissions Over Time\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Removed 11 rows containing missing values or values outside the scale range\n(`geom_line()`).\n```\n:::\n\n::: {.cell-output-display}\n![](07-trends-time-series_files/figure-html/unnamed-chunk-38-1.png){width=672}\n:::\n:::\n\n\nThere are just a few important things to keep in mind when using rectangular shading on time series:\n\n+ Similar to adding a vertical line, you need to make sure that your `xmin` and `xmax` are dates, written in the same dating format that's used in your data.\n\n+ For time series plots, you typically want the rectangular shading to span the entire y-axis (i.e., from the bottom to the top of the plot). So, you typically set `ymin = -Inf` and `ymax = Inf` (as above). Note that you need to specify `xmin`, `xmax`, `ymin`, *and* `ymax` within `geom_rect()`; otherwise you will get an error.\n\n+ Be sure to use `geom_rect()` before you draw any lines on your plot. For example, I put `geom_rect()` before `stat_rollapplyr()` above. Otherwise, the rectangle will cover the line of your plot:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nco2_tbl |>\n  ggplot(aes(x = obs_date, y = co2_val)) +\n  geom_line(color = \"red\") +\n  stat_rollapplyr(width = 12, align = \"right\") +\n  geom_rect(aes(xmin = as.Date(\"1980-01-01\"), xmax = as.Date(\"1989-12-31\"),\n                ymin = -Inf, ymax = Inf),\n            fill = \"grey\", alpha = 0.5) +\n  geom_vline(aes(xintercept = as.Date(\"01-01-1980\"))) +\n  labs(x = \"Year\", y = \"CO2 (ppm)\", \n       title = \"CO2 Emissions Over Time\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Removed 11 rows containing missing values or values outside the scale range\n(`geom_line()`).\n```\n:::\n\n::: {.cell-output-display}\n![](07-trends-time-series_files/figure-html/unnamed-chunk-39-1.png){width=672}\n:::\n:::\n\n\n\n# Lags and autocorrelation functions\n\nNow we will walk through how to compute autocorrelations using lags.\n\nImagine computing the autocorrelation at each lag (1, 2, 3, ...). For example, the autocorrelation at lag 1 is the correlation between the time series itself and the time series shifted back one timepoint. Computing the autocorrelation at each lag will thus give us a vector of autocorrelations, commonly called the **autocorrelation function** (ACF).\n\nYou can think of the ACF as taking in a lag $\\ell$ and spitting out a correlation between -1 and 1. The higher the correlation, the more dependent the time series measurements are on each other; and the larger the $\\ell$ with high correlation, the more this dependence \"lasts\" over time.\n\nBase `R` has the `acf()` function which can be used to compute and plot the ACF for a large number of lags.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacf(co2_tbl$co2_val)\n```\n\n::: {.cell-output-display}\n![](07-trends-time-series_files/figure-html/unnamed-chunk-40-1.png){width=672}\n:::\n:::\n\n\nAnd the `ggplot` version is:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nauto_corr <- acf(co2_tbl$co2_val, plot = FALSE)\nautoplot(auto_corr)\n```\n\n::: {.cell-output-display}\n![](07-trends-time-series_files/figure-html/unnamed-chunk-41-1.png){width=672}\n:::\n:::\n\n\nBy default, these plots display 95\\% confidence intervals, where autocorrelations outside this confidence interval are deemed \"unusually large.\" These intervals will depend on the data itself (for example, in another application, the intervals may not be $\\pm 0.1$), and the way these intervals are computed is outside the scope of this class (but it is easily googled for those interested; see the end of [this document](https://www.itl.nist.gov/div898/handbook/eda/section3/autocopl.htm) for example).\n\nBecause the autocorrelations are way above the confidence interval, we would say that this visual clearly shows that the `co2` data is highly autocorrelated, due to the strong global trend. What if we remove the trend, then look at the ACF of the residuals? We can compute moving averages using `rollapply` (in the `zoo` package, loaded when you load `ggseas`).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Use rollapply to compute a Moving Average, then compute residuals (co2_val - mov_ave)\nco2_tbl <- co2_tbl |>\n  mutate(mov_ave = \n           zoo::rollapply(co2_val, width = 12, FUN = \"mean\", \n                          align = \"right\", fill = NA),\n         res = co2_val - mov_ave)\n# Just to understand what this is doing, let's look\n# at the first few rows of the data:\nco2_tbl[1:13,]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 13 × 5\n   co2_val obs_i obs_date   mov_ave    res\n     <dbl> <int> <date>       <dbl>  <dbl>\n 1    315.     1 1959-01-01     NA  NA    \n 2    316.     2 1959-02-01     NA  NA    \n 3    316.     3 1959-03-01     NA  NA    \n 4    318.     4 1959-04-01     NA  NA    \n 5    318.     5 1959-05-01     NA  NA    \n 6    318      6 1959-06-01     NA  NA    \n 7    316.     7 1959-07-01     NA  NA    \n 8    315.     8 1959-08-01     NA  NA    \n 9    314.     9 1959-09-01     NA  NA    \n10    313.    10 1959-10-01     NA  NA    \n11    315.    11 1959-11-01     NA  NA    \n12    315.    12 1959-12-01    316. -0.396\n13    316.    13 1960-01-01    316.  0.373\n```\n:::\n:::\n\n\nJust to show that this is indeed the moving average:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nco2_tbl |>\n  ggplot(aes(x = obs_date)) +\n  geom_line(aes(y = mov_ave)) +\n  geom_line(aes(y = co2_val), color = \"red\") +\n  labs(x = \"Year\", y = \"CO2 (ppm)\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Removed 11 rows containing missing values or values outside the scale range\n(`geom_line()`).\n```\n:::\n\n::: {.cell-output-display}\n![](07-trends-time-series_files/figure-html/unnamed-chunk-43-1.png){width=672}\n:::\n:::\n\n\nNow let's look at a plot of the *residuals* (i.e., the observed outcomes minus the moving average), as well as an autocorrelation plot of the residuals:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Plot the residuals\nco2_tbl |>\n  ggplot(aes(x = obs_date, y = res)) +\n  geom_line() +\n  labs(x = \"Year\", y = \"Residuals of CO2 (ppm)\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Removed 11 rows containing missing values or values outside the scale range\n(`geom_line()`).\n```\n:::\n\n::: {.cell-output-display}\n![](07-trends-time-series_files/figure-html/unnamed-chunk-44-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# Compute ACF of the residuals\n# (except the first 11 cases, which are NA)\nautoplot(acf(tail(co2_tbl$res, -11), plot = FALSE))\n```\n\n::: {.cell-output-display}\n![](07-trends-time-series_files/figure-html/unnamed-chunk-44-2.png){width=672}\n:::\n:::\n\n\nNow what pattern do we see in the ACF plot? Which lags have the most positive and most negative values? What does this mean for monthly data?\n\nSee [this link](https://stackoverflow.com/questions/17788859/acf-plot-with-ggplot2-setting-width-of-geom-bar) for tips on mimicking the `acf()` plot in `ggplot`. For example, you can save the output of `acf()` and then put it inside a data frame:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nco2_acf <- acf(tail(co2_tbl$res, -11))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nco2_acf_df <- with(co2_acf, data.frame(lag, acf))\n# the resulting data.frame looks like this:\nhead(co2_acf_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  lag         acf\n1   0  1.00000000\n2   1  0.83287000\n3   2  0.42898732\n4   3 -0.05635883\n5   4 -0.47308749\n6   5 -0.73412921\n```\n:::\n\n```{.r .cell-code}\n# Then, we can make a simple \"bar\" plot:\n# (bar is in quotes because it's not displaying a categorical variable)\nggplot(co2_acf_df, aes(x = lag, y = acf)) + geom_bar(stat = \"identity\")\n```\n\n::: {.cell-output-display}\n![](07-trends-time-series_files/figure-html/unnamed-chunk-46-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# Alternatively, you could use:\n# ggplot(co2_acf_df, aes(x = lag, y = acf)) + geom_col()\n# which does the same thing.\n```\n:::\n\n\n# Seasonal decomposition\n\nRecall that, in lecture, we mentioned that there are three main characteristics of time series:\n\n+ **Trends**: The average increase or decrease in a variable over time.\n\n+ **Seasonality**: Changes in the variable that regularly happen (e.g., every winter, every hour, etc.)\n\n+ **Noise**: Variation in the variable beyond average trends and seasonality.\n\nThe idea above shows us that we can remove global trends from the dataset and then look for seasonal trends. The base `R` function `stl()` does this explicitly using loess smoothers:\n\n\"**S**easonal decomposition of **T**ime series by **L**oess\". It actually also separates the seasonal trend from the irregular / residual noise.\n\nIn `ggseas`, we can mimic this by using `ggsdc()` instead of starting with the `ggplot()` function. (The argument `s.window` is a kind of loess smoother span for the seasonal extraction.)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nco2_tbl |>\n  ggsdc(aes(obs_date, co2_val), \n        frequency = 12, method = \"stl\", s.window = 12) + \n  geom_line() +\n  labs(x = \"Year\", y = \"CO2 (ppm)\")\n```\n\n::: {.cell-output-display}\n![](07-trends-time-series_files/figure-html/unnamed-chunk-47-1.png){width=672}\n:::\n:::\n\n\nThe sum of \"trend\" + \"seasonal\" + \"irregular\" gives us back the original data, shown in \"observed\" (the top facet).\n\nDoes it look like `stl` found all interesting global or periodic trends, or is there any signal left in the \"irregular\" component?\n\nHere is the intuition for how the `stl()` function works:\n\n+ The \"trend\" component is obtained by fitting a loess curve to the time series. The smoothness of this loess is controlled by `frequency`.\n\n+ The \"seasonal\" component is obtained by fitting *another* loess curve on the residuals (observed - trend). The smoothness of *this* loess is controlled by `s.window`.\n\n+ The \"irregular\" component is obtained as the remaining residuals (observed - trend - seasonal).\n\nThis is technically not 100% correct, but it's very, very close to what actually happens within the `stl()` function; see `help(stl)` for details.\n\n\n\n",
    "supporting": [
      "07-trends-time-series_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}